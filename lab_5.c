/*11. —ортировка Ухитра€Ф.»з массива путем однократного просмотра выбираетс€ последовательность элементов,
наход€щихс€ в пор€дке возрастани€, перенос€тс€ в выходной массив и замен€ютс€ во входном на У-1Ф. «атем
оставшиес€ элементы включаютс€ в полученную упор€доченную последовательность методом погружени€.*/
#include <stdio.h>
#include <locale.h>

#define N 10

void ShowArray(int A[], int n);
void MaxPosl(int A[], int A2[], int n);
int main()
{
	setlocale(LC_ALL, "");
	int Arr[N] = { 30, 11,25,1,4,0,8,3,2, 5 };
	int Arr2[N];
	printf("¬ходной массив Arr: \n");
	ShowArray(Arr, N);

	MaxPosl(Arr, Arr2, N);

	return 0;
}

void ShowArray(int A[], int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		printf("%d ", A[i]);
	}
	printf("\n");
}

void MaxPosl(int A[], int A2[], int n)
{
	int max, k, num, x;
	//max - длина наиболее возр. посл-ти
	/*с i-эл-а начинаетс€ наиб длинна€ возр. послед-ть, если он первцый то перед ним есть и второй эл-т*/

	k = max = 0; /*сама€ маленька€ последовательность это пуста€ последовательность*/
	for (int i = 0; i < N - 1; i++) /*обходим массив*/
	{
		if (A[i + 1] > A[i]) /*если следующее число больше предыдущего*/
		{
			k++; /*длина наиб длинной послд-и, ихменилась, стала на 1 больше*/
		}
		else
			k = 0;

		if (k > max) //max - макс 
		{
			max = k;
			num = i + 1;
		}
	}
	max++;
	x = num - max + 1;
	printf("Ќаибольша€ возрастающа€ подпоследовательность: \n");

	for (int i = x; i < max + x; i++)
	{
		printf("%d ", A[i]);
	}

}


